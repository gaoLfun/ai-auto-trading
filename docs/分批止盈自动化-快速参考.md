# 分批止盈自动化系统 - 快速参考

## 🎯 核心改进

**问题**：原健康检查只记录分批止盈机会，不自动执行，时效性差（依赖AI Agent 15分钟循环）

**解决**：健康检查升级为自动执行，5分钟一次，时效性提升3倍，并通过分布式锁和去重机制与AI Agent互斥

## 🏗️ 系统架构

```markdown
健康检查(5min) ──┐
                 ├──> PartialTakeProfitExecutor ──> partialTakeProfitTool
AI Agent(15min) ─┘         (分布式锁 + 30秒去重)         (核心逻辑)
```

## 🔐 互斥机制

### 双重保护

1. **分布式锁**（在 PartialTakeProfitExecutor 中）
   - 锁键：`partial_tp_{symbol}_{side}_stage{N}`
   - 超时：30秒
   - 防止健康检查和AI Agent同时执行

2. **30秒去重**（在 partialTakeProfitTool 中）
   - 执行前检查历史表
   - 如果30秒内已有记录，直接跳过
   - 适用于所有调用路径

### 执行流程

```typescript
// 健康检查调用
PartialTakeProfitExecutor.executeCheck('health-check')
  └─> 遍历持仓
      └─> 对每个机会：
          1. 检查30秒内是否已执行（历史表）
          2. 尝试获取分布式锁
          3. 调用 partialTakeProfitTool.execute()
          4. 释放锁

// AI Agent调用
partialTakeProfitTool.execute({ symbol: 'ETH', stage: '1' })
  └─> 1. 检查30秒内是否已执行（历史表）
      2. 如果已执行，返回 { success: false, reason: 'recently_executed' }
      3. 继续原有逻辑
```

## 📁 修改文件

### 新增

- `src/services/partialTakeProfitExecutor.ts` - 统一执行器

### 修改

- `src/scheduler/healthCheck.ts` - 升级为自动执行
- `src/tools/trading/takeProfitManagement.ts` - 添加去重保护

## 🧪 验证方法

### 1. 检查日志

**健康检查成功执行**：

```markdown
✅ [health-check] ETH Stage1 自动执行成功
```

**去重保护生效**：

```markdown
⏭️ ETH Stage1 最近30秒内已执行，跳过
```

**锁冲突处理**：

```markdown
ETH Stage1 锁被占用，跳过
```

### 2. 查询历史表

```sql
-- 查看最近的分批止盈记录
SELECT symbol, stage, trigger_price, close_percent, timestamp, status 
FROM partial_take_profit_history 
WHERE timestamp > datetime('now', '-1 hour')
ORDER BY timestamp DESC;
```

### 3. 监控指标

- 健康检查执行次数：每小时 ~12次（每5分钟）
- AI Agent执行次数：每小时 ~4次（每15分钟）
- 跳过率：应该接近 75%（健康检查执行后，AI Agent会跳过）

## ⚡ 常见场景

### 场景1：正常执行（健康检查优先）

```markdown
00:00  健康检查检测到 ETH 1.2R
00:00  执行 Stage1 分批止盈
00:10  AI Agent 检测到 ETH，查询历史表
00:10  发现10秒前已执行，跳过
```

### 场景2：AI Agent独立执行

```markdown
00:00  AI Agent 检测到 BTC 2.1R
00:00  查询历史表，无近期记录
00:00  执行 Stage2 分批止盈
00:03  健康检查检测到 BTC
00:03  查询历史表，发现3秒前已执行，跳过
```

### 场景3：并发冲突

```markdown
00:00.000  健康检查尝试获取锁
00:00.100  AI Agent 尝试获取锁
00:00.200  健康检查获取锁成功
00:00.300  AI Agent 发现锁被占用，跳过
```

## 🔧 配置参数

| 参数 | 位置 | 默认值 | 说明 |
|------|------|--------|------|
| 健康检查间隔 | `healthCheck.ts` | 5分钟 | 通过 cron 表达式控制 |
| AI Agent间隔 | `tradingLoop.ts` | 15分钟 | 通过 cron 表达式控制 |
| 锁超时时间 | `partialTakeProfitExecutor.ts` | 30秒 | `LOCK_TIMEOUT_MS` |
| 去重时间窗口 | `partialTakeProfitExecutor.ts` | 30秒 | `hasRecentExecution()` |
| 去重时间窗口 | `takeProfitManagement.ts` | 30秒 | execute 函数开头 |

## 🎓 关键技术点

### 为什么需要双重保护？

- **分布式锁**：防止健康检查和AI Agent同时执行（并发控制）
- **30秒去重**：防止执行器被绕过直接调用工具（兜底保护）

### 为什么用历史表而不是内存锁？

- 跨进程可见（如果使用多实例部署）
- 持久化，重启不丢失
- 可审计，方便排查问题

### 为什么是30秒？

- 市场波动缓冲：R倍数短时间内不会大幅变化
- 与锁超时对齐：一致性更好
- 避免影响AI Agent正常执行（15分钟间隔）

## 📊 性能影响

- **额外查询**：每次执行前1次历史表查询（SELECT COUNT，很快）
- **锁开销**：`system_config` 表读写（轻量级）
- **总体影响**：可忽略（<10ms）

## 🚨 注意事项

1. **不要直接修改历史表**：会影响去重判断
2. **不要手动释放锁**：让系统自动超时释放
3. **不要修改去重时间窗口**：30秒经过测试验证

## 📖 相关文档

- [完整实施方案](./分批止盈自动化-实施完成.md)
- [系统健康警示灯](./系统健康警示灯-使用说明.md)
- [科学止损系统](./科学止损系统-快速入门示例.md)
